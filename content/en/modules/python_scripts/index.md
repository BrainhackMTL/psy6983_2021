---
type: "modules" # DON'T TOUCH THIS ! :)

# Title of your project (we like creative title)
title: "Writing scripts in python"

# Your project GitHub repository URL
github_repo:

# If you are working on a project that has website, indicate the full url including "https://" below or leave it empty.
website:

# List +- 4 keywords that best describe your project within []. Note that the project summary also involves a number of key words. Those are listed on top of the [github repository](https://github.com/PSY6983-2021/project_template), click `manage topics`.
# Please only lowercase letters
tags: [python, scripts]

# Summarize your project in < ~75 words. This description will appear at the top of your page and on the list page with other projects..

summary: "Learning the basics of python scripts' structure. Turning jupyter notebooks into scripts that can be run from anywhere. Introduction to the argument parser."

# If you want to add a cover image (listpage and image in the right), add it to your directory and indicate the name
# below with the extension.
image: "python-file-icon.jpg"
---
<!-- This is an html comment and this won't appear in the rendered page. You are now editing the "content" area, the core of your description. Everything that you can do in markdown is allowed below. We added a couple of comments to guide your through documenting your progress. -->

## Information

The estimated time to complete this training module is 2h.

The prerequisites to take this module are:
 * the [installation](/modules/installation) module.

Contact François Paugam if you have questions on this module, or if you want to check that you completed successfully all the exercises.

## Resources
This module was presented by [Greg Kiar](https://github.com/gkiar) during the QLSC 612 course in 2020, with [slides](https://docs.google.com/presentation/d/1n2RlMdmv1p25Xy5thJUhkKGvjtV-dkAIsUXP-AL4ffI/edit#slide=id.g362da58057_0_1) from Joel Grus' talk at JupyterCon 2018.

The video is available below:
<iframe width="560" height="315" src="https://www.youtube.com/embed/zpOQENxs1G4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


## Exercise

 * In a new directory, create a file `useful_functions.py`.
 * In this file, implement a function `change_case` that takes as input a string and that returns this string with the last character in upper case and the rest in lower case (e.g. `"myInputString"` -> `"myinputstrinG"`). Hint : use the `.upper()` and `.lower()` methods of the string type.
 * In the same file, implement an other function `get_words` that takes a string as input and returns a list of strings. The list should contain the words in the input string (e.g. `"My input string"` -> `["My", "input", "string"]`). Hint : use the `.split()` method.
 * In the same file, implement a third function `join_words` that does the reverse as the `get_words` function, i.e. taking a list of word and returning one string with all the words (e.g. `["My", "input", "string"]` -> `"My input string"`).
 * Create a new file `main_script.py`. In this file use the Argparse library introduced in the video so that a user can call it with two arguments : a `--text` argument containing a string and a `--case` argument which can take the value "upper", "lower" or "mixed". The script should print the text argument with the case asked (mixed being the one generated by the `change_case` function). For example :
 ```
 ./main_script --text "My awesome text." --case mixed
 mY awesomE texT.

 ./main_script --text "My awesome text." --case upper
 MY AWESOME TEXT.
 ```
 Hint : import and use the functions from the `useful_functions.py` file. Don't forget the `if __name__ == "__main__"` even though in this example it won't make a difference, it is never too early to get used to good practices.
 * Follow up with François Paugam to validate you completed the exercise correctly.
 * :tada: :tada: :tada: you completed this training module! :tada: :tada: :tada:

<br>
<details>

<summary> <h2> Bonus exercise (click to show) <h2/></summary>

{{% content "content/en/modules/python_scripts/bonus_exercise.md" %}}

</details>
<br>

## On the usefulness of `if __name__ == "__main__":`

It is not obvious why you shoud put the `if __name__ == "__main__":` line in your script. Indeed in a lot of cases, putting it or not won't change anything to how your code runs. But in specific settings with multiple scripts importing from each pother, not putting it in can quickly lead to a nightmare.
To give you an insight of how and why it is useful, here is an example.

Suppose you have a script to fit a Ridge model on provided data, judiciously named `fit_Ridge.py`, which looks like this :
```
#!/usr/bin/env python
import argparse
import pickle  # pickle is a librairie to save and load python objects.
import numpy as np
from sklearn.linear_model import Ridge

def  fit_Ridge_model(X, Y):
  model = Ridge()
  model.fit(X, Y)
  return model

parser = argparse.ArgumentParser()
parser.add_argument("--X_data_path", type=str)
parser.add_argument("--Y_data_path", type=str)
parser.add_argument("--output_path", type=str)
args = parser.parse_args()

X = np.load(args.X_data_path)
Y = np.load(args.Y_data_path)
model = fit_Ridge_model(X, Y)
pickle.dump(model, open(args.output_path, 'wb'))
```
This script allows the user to provide the paths to two numpy files as data to fit a Ridge model, and to save the model to the provided path with a command like :
```
python fit_Ridge.py --X_data_path data_folder/X.npy --Y_data_path data_folder/Y.npy --output_path models/Ridge.pk
```
There is no `if __name__ == "__main__":` to be seen but, used on its own, the script works fine.

But later, you write an other script `compare_to_Lasso.py` that compare Ridge and Lasso models on the same data, so you need to fit a Ridge model again. Eager to apply the good practices of programming, you judiciously decide not to duplicate the code for fitting a ridge model, but to import the `fit_Ridge_model` function from the `fit_Ridge.py`. Thus your second script looks like that :
```
#!/usr/bin/env python
import numpy as np
import argparse
from sklearn.linear_model import Lasso
from fit_Ridge import fit_Ridge_model

parser = argparse.ArgumentParser()
parser.add_argument("--X_data_path", type=str)
parser.add_argument("--Y_data_path", type=str)
args = parser.parse_args()

X = np.load(args.X_data_path)
Y = np.load(args.Y_data_path)

ridge_model = fit_Ridge_model(X, Y)
lasso_model = Lasso()
lasso_model.fit(X, Y)

ridge_score = ridge_model.score(X, Y)
lasso_score = lasso_model.score(X, Y)

if Ridge_score > lasso_score:
    print("Ridge model is better.")
else:
    print("Lasso model is better.")
```

It seems fine but here when you try to call
```
python compare_to_Lasso.py --X_data_path data_folder/x.npy --Y_data_path data_folder/Y.npy
```
you get an error :
```
Traceback (most recent call last):
  File "compare_lasso_ridge.py", line 5, in <module>
    from fit_Ridge import fit_Ridge_model
  File "/Users/francois/scratch/fit_Ridge.py", line 21, in <module>
    pickle.dump(model, open(args.output_path, 'wb'))
TypeError: expected str, bytes or os.PathLike object, not NoneType
```

The error shows that the script tried to save a model to the path `args.output_path`, which was not defined so it was set to None and raised a TypeError. But our `compare_to_Lasso.py` script never tries to save a model ! Indeed looking at the other lines of the error message, we see that it comes from the import. In fact what happens is that when we try to import the `fit_Ridge_model` fuction from the `fit_Ridge.py` file, python will read the entire file and execute everything that is written in it, so it will try to fit a Ridge model and to save it. But we don't want python to execute everything, we just want it to read the definition of the `fit_Ridge_model` function. That is why here we absolutely need the `if __name__ == "__main__":`, so we modify the `fit_Ridge.py` script like that :
```
#!/usr/bin/env python
import argparse
import pickle  # pickle is a librairie to save and load python objects.
import numpy as np
from sklearn.linear_model import Ridge

def  fit_Ridge_model(X, Y):
    model = Ridge()
    model.fit(X, Y)
    return model

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--X_data_path", type=str)
    parser.add_argument("--Y_data_path", type=str)
    parser.add_argument("--output_path", type=str)
    args = parser.parse_args()

    X = np.load(args.X_data_path)
    Y = np.load(args.Y_data_path)
    model = fit_Ridge_model(X, Y)
    pickle.dump(model, open(args.output_path, 'wb'))
```
Now when importing from this script, python will read the definition of the function, but after that it will not execute the rest, since during the import the variable `__name__` is not set to `"__main__"` but to `"fit_Ridge"`.

In the end using `if __name__ == "__main__":` is the only way to safely import functions from our script, and since you never know for sure that you won't have to import something from a script in the future, putting it in all of your script by default is not a bad idea.


## More resources

If you are curious to learn more advanced capabilities for the Argparse library, you can check this [Argparse tutorial](https://docs.python.org/3/howto/argparse.html).

To learn more about python in general, you can check the [tutorials of the official python documentation](https://docs.python.org/3/tutorial/) and choose the topic you want to learn. I also recommend the [porgramiz tutorials](https://www.programiz.com/python-programming) which have nice videos. Finally for even nicer and fancier videos there is the excellent [python programming playlist](https://www.youtube.com/playlist?list=PLi01XoE8jYohWFPpC17Z-wWhPOSuh8Er-) from the youtube channel Socratica.
